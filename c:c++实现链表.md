## c/c++实现链表



### 引入

链表是一种用于存储数据的数据结构，通过如链条一般的指针来连接元素。它的特点是

- 插入与删除数据十分方便，
- 但寻找与读取数据的表现欠佳。

### 与数组的区别

链表和数组都可用于存储数据。与链表不同，数组将所有元素按次序依次存储。不同的存储结构令它们有了不同的优势：

- 链表因其链状的结构，能方便地删除、插入数据，操作次数是 $O(1)$。但也因为这样，寻找、读取数据的效率不如数组高，在随机访问数据中的操作次数是 $O(n)$。

- 数组可以方便地寻找并读取数据，在随机访问中操作次数是 $O(1)$。但删除、插入的操作次数是$O(n)$次。



### 什么是链表



下面创建一个链表：

![三个节点的整型链表](/Users/guanjin/Documents/cppProject/LeetCodeNote/pic/链表/list1.png)





- 每个节点都有两个字段或两个部分，一个用于存储数据,称为`数据域`，另一个存储下一个节点的地址，称为`指针域`，还可以称为下一个节点的链接`link`

- 上图中，假设第一个节点的地址为`200`，第二个节点的地址为`100`，第三个节点的地址为`300`

- 第一个节点的地址部分为`100`，第二个节点的地址部分为`300`，最后一个节点的地址部分为`NULL`，这是一个地址为0的同义词或宏

- `0`是无效地址，指针变量等于`0`或为`NULL`，地址为`0`或`NULL`表示指针变量未指向有效的内存位置

- 分配的内存块的地址，对每个节点来讲都是`完全随机的`，彼此没有关系，不能保证地址一定是升序的、降序的或是彼此相邻的，这就是为什么我们需要存储这些链接的地址

  

  

  为了表示这个链表，我们需要维护的是`第一个节点的地址`，也称为`头节点`，因此，我们使用另一个变量，该变量的类型是指向节点的指针，存储第一个节点的地址，可以任意命名这个指针变量，比如指针变量的名称为`A`，如下图：



![链表2](/Users/guanjin/Documents/cppProject/LeetCodeNote/pic/链表/list2.png)





该指针变量`A`指向头节点或第一个节点，也可以解释为链表的名称，因为这是链表的唯一标识，现在看看这种逻辑试图是如何在c或c++程序中实现的

### c/c++实现链表

在我们的程序中，节点将是一个数据类型，它将具有两个域，一个用于存储数据，另一个用于存储地址，在c语言中，我们可以将数据类型定义为结构体，因此我们可以用两个字段定义一个名为`node`的结构体，第一个用于存储数类型，数据类型，可以是整型`int data` 或是double类型的数据链表，第二个字段将是指向节点的`指针`，我们可以命名为`link`，可以命名为`next`，或是其他任意名称；



如图为c语言的定义格式

![list3](/Users/guanjin/Documents/cppProject/LeetCodeNote/pic/链表/list3.png)



c语言代码实现:

```c
struct Node {
  int data;
  struct Node* next;
}
```



c++定义格式为

![list4](/Users/guanjin/Documents/cppProject/LeetCodeNote/pic/链表/list4.png)

c++语言代码实现:

```c
struct Node {
  int data;
  Node* next;
}
```



在我们的逻辑视图中，此变量`A`的类型为`Node*` 或者说是指向节点的指针，这三个矩阵的节点各有两个字段，节点中第一个字段是节点类型，图中是整型类型，第二个字段是指向节点的指针类型，`Node`或`Node*`

![list5](/Users/guanjin/Documents/cppProject/LeetCodeNote/pic/链表/list5.png)



下面继续创建这个特定的整型链表：

必须执行两个操作:

- 一个是将节点插入链表，

- 另一种是遍历链表的操作

  但在此之前，要做的事，声明一个指向头节点的指针，一个将存储头节点地址的变量，为了清楚起见，我将在此处编写头节点，



声明一个指向节点的指针A

```cpp
Node* A；
```

最初当列表为空时，在列表中没有元素，该指针不应指向任何位置，所以我们写一个类似`A=NULL`的语句，说的是同一件事情

```cpp
Node* A;
A = NULL;
```

使用这两个语句，我们创建了一个指向节点的指针`A`，并且该指针不指向任何具体节点，因此列表为空，



![list6](/Users/guanjin/Documents/cppProject/LeetCodeNote/pic/链表/list6.png)

现在假设我们要在此列表中插入一个节点，首先要做的是创建一个节点，创建一个节点只不过是创建一个存储块来存储节点，在c语言中，我们使用函数`malloc`创建一个内存块，如下所示

```c
malloc(sizeof(Node))
```

- 参数是内存块所需的字节数,所以我们说给我一个内存块，它等于节点的大小
- 因此，对`malloc`的调用将创建一个内存块：动态分配的内存，运行时分配的内存

处理这种内存的唯一方法，就是通过指针来引用该内存，让我们假设这里分配的内存储块位于地址`200`，

![list7](/Users/guanjin/Documents/cppProject/LeetCodeNote/pic/链表/list7.png)



```cpp
Node* temp = (Node*)malloc(sizeof(Node))
```

- 现在`malloc`返回一个`void`指针，该指针为我们提供分配的内存块的地址，所以我们需要将其保存到某个地方，
- 假设我们创建了一个名为`temp`的变量是指向节点的指针，因此我们可以得到`malloc`的返回值，就是内存的具体地址,
- 我们这里需要类型转换，因为`malloc`返回`void`指针，我们将`temp`作为指向节点的指针，因此现在我们在节点中创建了一个节点

现在，我们需要做的是填写该节点的数据，并调整链接，这意味着向变量`A`中写入正确的地址以及调整新创建的节点的链接字段，为此，我们必须解引用此特定指针，也就是我们刚刚创建的变量，



如我们所知，在指针前面加上`*`号，我们的意思是解引用和修改特定地址的值，现在这种情况下，我们有一个节点，两个字段，因此解引用了之后，我们需要在此处填入数据字段，因此，我们将在此处编写这样的语句，填入数据字段2

```cpp
(*temp).data = 2;
```

我们这个临时变量现在指向这个节点，现在，这个新创建的链接部分应该是`NULL`，因此这是第一个也是最后一个节点,如图：



![list8](/Users/guanjin/Documents/cppProject/LeetCodeNote/pic/链表/list8.png)





代码表示：

```cpp
(*temp).link = NULL;
```

我们要做的最后一件事是把新创建的节点的地址`200`写入`A`，因此我们写类似于这样的语句`A=temp`

```cpp
A = temp;
```

`temp`	是用来暂时存储节点地址的，一旦链接调整完成之后，就可以将`temp`用于其他目的了，至此我们的链表已经是完整的了：它有一个节点



```cpp
(*temp).data = 2;
(*temp).link = NULL;
```

这两行用于解引用，并将值写入新节点，这里还有另一个可选的写法，不是编写类似`(*temp)`,我们也可以写`temp`,然后跟上一个箭头和数据，这里箭头包含两个字符`- `和`>`

```cpp
temp->data = 2;
temp->link = NULL;
```



```cpp
Node* temp = (Node*)malloc(sizeof(Node))
```

要在`c++`中创建一个内存块，我们可以使用`malloc`或者我们可以使用`new`运算符，在`c++`中我们可以简单的写

```cpp
Node* temp = new Node();
```



到目前为止，我们创建了一个空链表，

```cpp
Node* = A;
A = NULL;
```

指向头节点的指针，并将值NULL分配给它。然后创建了一个节点，在此链表中添加了第一个节点，





```text
当列表为空，并且我们想要插入节点，逻辑非常简单
当列表不为时，我们可能要在列表的开头、列表的末尾，或者我们可能想要在列表中加的某个位置插入，我们将为不同类型的插入一个节点，我们将为不同类型的节点插入编写单独的函数
```



下面再在末尾插入两个节点。这个链表的三个节点的值分别为2、4、6



我们已经有一个指向这个特定节点的变量temp，如图所示：

![list9](/Users/guanjin/Documents/cppProject/LeetCodeNote/pic/链表/list9.png)



我们将创建一个新的节点并使用相同的变量名来保存这个新节点的地址

```cpp
temp = new Node();
```

这样就创建了一个新节点和temp现在存储新节点的地址，即位于此处的地址100，如图：

![list10](/Users/guanjin/Documents/cppProject/LeetCodeNote/pic/链表/list10.png)





再次，可以设置数据

```cpp
temp -> data = 4;
```

然后因为这将是最后一个节点，我们需要将链接设置为NULL

```cpp
temp -> link = NULL;
```



现在要做的是要将新创建的节点的地址写入到最后一个节点的地址字段，为此我们必须遍历链表，我们不得不到达链表的末尾，为此，我们将编写如下内容：

我们可以创建一个新的变量temp1,该变量将指向一个节点，最初，我们可以将该节点指向头节点

```cpp
Node* temp1 = A;
```

通过这样的声明，我们可以写一个循环，这是到达链表末尾的通用逻辑

```cpp
while (temp1 -> link != NULL){
  temp1 = temp1 -> link;
}
```



如果要打印链表元素：

```cpp
Node* temp1 = A;
while (temp1 -> link != NULL){
  temp1 = temp1 -> link;
  print "temp->data";
}
```

这样遍历，temp1从头节点到达最后一个节点



还想指出一件事，我们正在使用此变量temp1，最初将存储A 的地址，我们没有做类似A=A.link的事情，也就是没有使用变量A本身来遍历列表，因为如果那样做的话，我们是在修改A，我们将丢失头节点的地址，所以A永远不会被修改，存储头节点的地址从不应该被修改，我们仅修改此临时变量以遍历链表，最后写一条声明，

```cpp
temp1->link=temp
```



因此，此地址部分已更新并建立此链接，所以我们在列表中有两个节点，如图：

![list11](/Users/guanjin/Documents/cppProject/LeetCodeNote/pic/链表/list11.png)



也即为

![list12](/Users/guanjin/Documents/cppProject/LeetCodeNote/pic/链表/list12.png)

同样的，在此列表中插入编号为6的节点，我们将必须创建一个新节点，然后我们将不得不遍历链表，因此我们首先将temp1指向此处，头节点，如图

![list13](/Users/guanjin/Documents/cppProject/LeetCodeNote/pic/链表/list13.png)



循环会将temp1移动到末尾，如图

![list14](/Users/guanjin/Documents/cppProject/LeetCodeNote/pic/链表/list14.png)



假设这个新区块位于地址300，最后将调整地址为100的节点的链接，再最后插入节点，如图

![liat15](/Users/guanjin/Documents/cppProject/LeetCodeNote/pic/链表/list15.png)



